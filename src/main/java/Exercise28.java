public class Exercise28 {
    /**
     * @param haystack 主字符串
     * @param needle   模式字符串
     * @return 抛开推导的数学公式, 该算法的主要思想就是:
     * 将主字符串不断移动,同时不断移动模式字符串,同时移动模式字符串,但是这个算法最关键的点在于:
     * 如果发生了不匹配的情况下,是将字符串的公共前缀移动到字符串的公共后缀部分,这样就可以减少计算量,
     * 因此该算法最关键的步骤之一就是计算出公共前后缀组成的数组,也就是代码中的next数组
     */
    public static int strStr(String haystack, String needle) {
        int len = needle.length();
        if (len == 0) {
            return 0;
        }
        int[] next = new int[len];
        next[0] = 0;
        int j = 0;
        /*
          下面就是计算最大公共前后缀数组的代码
          代码的涉及的思路如下:
          假设现在的字符串是aabaa,那么想要该字符串的最大公共前后缀加1,那么只能是b加进来才满足条件
          所以if条件needle.charAt(j) == needle.charAt(i)满足的时候,j也就是记录最大公共前后缀的变量值加1
          但是代码设计的时候麻烦的点就在于加入的字符不符合上面的条件,这个时候还得分情况讨论
          如果既不是a也不是b直接就是0,但是如果是a这种情况的话,就需要进一步判断
          这里提示一种情况就是:j = next[j - 1]回退到最大公共前缀部分,j > 0,
          而且接下来的判断needle.charAt(j) == needle.charAt(i))成立,说明一定是类似于aabaa这种情况
          如果一直回溯到j = 0的情况的话,那么最后就是判断第一个字符和新加入的字符是否相等
          如果相等j就加1,不相等就是0,可以想像一下abc然后加入一个a的情况
         */
        for (int i = 1; i < len; i++) {
            while (needle.charAt(j) != needle.charAt(i) && j > 0) {
                j = next[j - 1];
            }
            if (needle.charAt(j) == needle.charAt(i)) {
                j++;
                next[i] = j;
            }

        }
        /*
          下面就是借助next数组进行匹配的过程:
          如果一直匹配成功的话,代码十分好理解将标记加1,然后主字符串的指针移动一位就可以,
          但是问题就在于如果不相等的话,那么就需要回溯到公共前缀的位置k = next[k - 1]
          如果进行回溯到公共前缀的位置的时候发现公共前缀的下一个字符和主字符串当前的字符不相同的时候,
          就进行之前的步骤,直到回溯到模式字符串的第一个字符或者找到公共前缀的下一个字符和主字符串当前的字符相同的时候
          其实如果是一般的情况if判断也是可以满足很多情况的,如果是if判断的话,代码也会十分好理解,
          但是如果存在这种情况的话:主字符串是abbababbabbbabaa,模式字符串是abbabbbabaa,
          那么匹配到第六个字符,也即是abbaba的时候,此时k经过调整以后是2,此时也是没有问题的
          但是,进行到下一步的时候会出现问题:由于k经过调整等于0,然后此时i=6,k的值满足if条件判断
          然后k=3,但是实际上,现在已经打乱了顺序,得出的结论是错误的,这是由于判断的时候跳过了i=5造成的
          所以if判断的失误点就在于:如果经过调整之后的k值仍然大于1,
          但是最大公共前缀的下一位和主字符串的当前字符又不相等的情况下,就会出现问题,注意:这个是不会经过任何逻辑就进入循环了
          这就会造成中间有字符没有比较,就本例具体来说就是模式字符串的第二个字符,所以整个比较逻辑就不正确了
          所以这里就需要通过while循环自己先进行判断,如果不相等说明不匹配,就先进行处理,然后再走下面的if判断
         */
        for (int i = 0, k = 0; i < haystack.length(); i++) {
            while (k > 0 && haystack.charAt(i) != needle.charAt(k)) {
                k = next[k - 1];
            }
            if (haystack.charAt(i) == needle.charAt(k)) {
                k++;
                if (k == len) {
                    return i - k + 1;
                }
            }
        }
        return -1;
    }
}
