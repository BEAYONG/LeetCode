public class Exercise53 {
    /**
     *
     * @param nums
     * @return
     * 要求求出最大子列和:下面的方法中使用到的是动态规划的思想
     * 首先解释一下各个变量的含义:
     * sum保存的是各个区间中的最大值,所以才有了for循环中代码:
     * 如果当前区间值还是大于0的时候,那么无论是什么值都可以加上去,因为sum只要大于0,
     * 就为后面的区间大于0保存了一丝的可能性,所以sum = sum + nums[i]
     * 但是如果小于0,那么这段区间就不可能使得后面的区间的和更大,所以就直接放弃了,
     * 这个的体现就在于将sum的值更新为下一个值
     *
     * 接下来,还有一段比较难理解的地方就是为什么通过result = Math.max(result, sum)就可以得到最大值
     * 其实是因为这样:当我们从头开始遍历数组的时候,result保留了前面的子区间的最大值,
     * 后面如果出现的是正数,理所当然,最大值会更新,因为sum = sum + nums[i]把这个正数加上了
     * 如果后面是一个复数,但是又不至于大于sum,那么通过比较,最大值还是保持原样
     * 如果后面是一个复数接着又是正数的话,而且复数的绝对值小于正数的话,注意的是根据之前的解释,
     * 我们可以直到该区间的的子序列和是会被保留的,所以通过比较,可以知道新的子区间的最值大于原来的最大值也就是会更新,
     * 所以最后的结果就是正确的
     *
     * 所以这道题的主要解题思路就是:维持一个变量记录子序列和,如果大于0就保留,小于0就去除,最后在每次循环都更新
     */
    public static int maxSubArray(int[] nums) {
        int result = nums[0];
        int sum = 0;
        for (int i = 0; i < nums.length; i ++){
            if (sum > 0){
                sum = sum + nums[i];
            }else {
                sum = nums[i];
            }
            result = Math.max(result, sum);
        }
        return result;
    }
}
